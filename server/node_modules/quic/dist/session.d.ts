/// <reference types="node" />
import { EventEmitter } from 'events';
import { Offset, SessionType, StreamID, PacketNumber, ConnectionID, SocketAddress } from './internal/protocol';
import { kID, kFC, kRTT, kStreams, kSocket, kState, kType, kVersion, kACKHandler, kNextStreamID, kNextPacketNumber, kIntervalCheck, kUnackedPackets } from './internal/symbol';
import { Frame, StreamFrame, RstStreamFrame, AckFrame, WindowUpdateFrame, StopWaitingFrame, BlockedFrame } from './internal/frame';
import { Packet, RegularPacket } from './internal/packet';
import { ConnectionFlowController } from './internal/flowcontrol';
import { RTTStats } from './internal/congestion';
import { Socket } from './socket';
import { Stream } from './stream';
import { BufferVisitor, Queue } from './internal/common';
export declare class Session extends EventEmitter {
    protected [kID]: ConnectionID;
    protected [kType]: SessionType;
    protected [kIntervalCheck]: NodeJS.Timer | null;
    protected [kStreams]: Map<number, Stream>;
    protected [kNextStreamID]: StreamID;
    protected [kState]: SessionState;
    protected [kACKHandler]: ACKHandler;
    protected [kSocket]: Socket | null;
    protected [kVersion]: string;
    protected [kNextPacketNumber]: PacketNumber;
    protected [kUnackedPackets]: Queue<RegularPacket>;
    protected [kRTT]: RTTStats;
    protected [kFC]: ConnectionFlowController;
    constructor(id: ConnectionID, type: SessionType);
    readonly id: string;
    readonly version: string;
    readonly isClient: boolean;
    readonly destroyed: boolean;
    readonly localAddr: {
        address: string;
        family: string;
        port: number;
        socketAddress: SocketAddress | null;
    };
    readonly remoteAddr: {
        address: string;
        family: string;
        port: number;
        socketAddress: SocketAddress | null;
    };
    _newRegularPacket(): RegularPacket;
    _sendFrame(frame: Frame, callback?: (...args: any[]) => void): void;
    _sendStopWaitingFrame(leastUnacked: number): void;
    _retransmit(frame: AckFrame, rcvTime: number): number;
    _sendPacket(packet: Packet, callback?: (...args: any[]) => void): void;
    _sendWindowUpdate(offset: Offset, streamID?: StreamID): void;
    _trySendAckFrame(): void;
    _handleRegularPacket(packet: RegularPacket, rcvTime: number, bufv: BufferVisitor): void;
    _handleStreamFrame(frame: StreamFrame, rcvTime: number): void;
    _handleRstStreamFrame(frame: RstStreamFrame, rcvTime: number): void;
    _handleACKFrame(frame: AckFrame, rcvTime: number): void;
    _handleStopWaitingFrame(frame: StopWaitingFrame): void;
    _handleWindowUpdateFrame(frame: WindowUpdateFrame): void;
    _handleBlockedFrame(frame: BlockedFrame, rcvTime: number): void;
    _intervalCheck(time: number): void;
    request(options?: any): Stream;
    goaway(err: any): Promise<void>;
    ping(): Promise<void>;
    setTimeout(_msecs: number): void;
    close(err?: any): Promise<void>;
    reset(_err: any): Promise<void>;
    destroy(err: any): void;
}
export declare class SessionState {
    localFamily: string;
    localAddress: string;
    localPort: number;
    localAddr: SocketAddress | null;
    remoteFamily: string;
    remoteAddress: string;
    remotePort: number;
    remoteAddr: SocketAddress | null;
    maxPacketSize: number;
    bytesRead: number;
    bytesWritten: number;
    idleTimeout: number;
    liveStreamCount: number;
    lastNetworkActivityTime: number;
    destroyed: boolean;
    shutdown: boolean;
    shuttingDown: boolean;
    versionNegotiated: boolean;
    keepAlivePingSent: boolean;
    constructor();
}
export declare class ACKHandler {
    misshit: number;
    lowestAcked: number;
    largestAcked: number;
    numbersAcked: number[];
    largestAckedTime: number;
    lastAckedTime: number;
    constructor();
    lowest(packetNumber: number): void;
    ack(packetNumber: number, rcvTime: number, needAck: boolean): boolean;
    toFrame(): AckFrame | null;
}
